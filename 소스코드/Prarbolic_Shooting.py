{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 신경망 학습을 위해 게임으로부터 데이터 수집\n",
    "# 타겟이 포물선 운동을 할 때 발사체를 임의의 각도로 발사하여 우연히 명중되는 빈도수를 확인한다\n",
    "# window.hit_state : 명중한 발사체로부터 수집된 타겟 상태(x, y)\n",
    "# window.hit_rad : 명중한 발사체로부터 수집된 발사 각도(radian)\n",
    "\n",
    "import time\n",
    "\n",
    "print('무작위 대응으로 게임 데이터 수집')\n",
    "states = []\n",
    "# 데이터가 많을수록 학습효과와 정확도가 높다\n",
    "for e in range(300):\n",
    "    state = window.reset()\n",
    "    done = False\n",
    "    while not done:\n",
    "        rad = math.radians(np.random.randint(0,180))  # 무작위 발사 각\n",
    "        action = 1\n",
    "        state,reward,done,info = window.step(1,rad)   # action=1 으로 발사 요청\n",
    "        states.append(state)\n",
    "        #time.sleep(0.02)\n",
    "    print('Episode %s fires %s hits %s' % (e+1, window.fireCnt, window.hits) )\n",
    "print('데이터 수집 종료')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 신경망에 사용할 수 있도록 데이터 처리\n",
    "# 발사여부, 발사각을 계산할 수 있는 신경망 2개를 사용할 목적으로 처리\n",
    "# 발사여부를 계산할 신경망을 학습할 문제(x,y), 정답(0 or 1)\n",
    "\n",
    "import numpy as np\n",
    "fire_label = []\n",
    "\n",
    "for s in states:\n",
    "    ohe = np.zeros(2)               # 원핫 인코딩용 \n",
    "    if s in window.hit_state:       # 맞췄을때의 상태가 현재 상태와 같을때\n",
    "        ohe[1] = 1                  # 1을 넣어준다\n",
    "    else: ohe[0] = 1\n",
    "    fire_label.append(ohe)\n",
    "\n",
    "stateX = np.array(states)           #모든 상태정보를 ndarray로 만듬\n",
    "fireY = np.array(fire_label)        # 0과 1로 이루어진 list를 ndarray로 만듬\n",
    "\n",
    "print(type(stateX), stateX.shape)\n",
    "print(type(fireY), fireY.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 발사각 계산용 신경망을 학습시킬 데이터 준비( 문제(x,y), 정답(rad))\n",
    "#총알이 타겟에 맞춘 상태정보를 문제로 넣기위해 만든 변수\n",
    "hit_stateX = np.array(window.hit_state)    #맞췄을때의 상태\n",
    "#스칼라 데이터를 np.array로 만듬\n",
    "hit_radY = np.array(window.hit_rad).reshape(-1,1) # 맞췄을때의 rad각도\n",
    "\n",
    "print(type(hit_stateX), hit_stateX.shape)\n",
    "print(type(hit_radY), hit_radY.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "action_model = create_fire_model()\n",
    "action_model.fit(stateX, fireY, epochs=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rad_model = create_rad_model()\n",
    "rad_model.fit(hit_stateX, hit_radY, epochs=200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 학습된 모델의 가중치(Weight)를 파일에 저장\n",
    "action_model.save('action_model_weights.h5')\n",
    "rad_model.save('rad_model_weights.h5')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 포물선 운동 애니메이션\n",
    "# 이동 애니메이션\n",
    "\n",
    "import sys\n",
    "import time\n",
    "import math\n",
    "import gym\n",
    "import numpy as np\n",
    "from PyQt5.QtCore import *\n",
    "from PyQt5.QtWidgets import *\n",
    "from PyQt5.QtGui import *\n",
    "from tensorflow.keras.models import Sequential\n",
    "from tensorflow.keras.layers import Dense, Flatten\n",
    "from tensorflow.keras.optimizers import Adam\n",
    "\n",
    "# 발사 여부를 계산할 신경망 생성\n",
    "# 뉴런의 수와 은닉층의 수는 테스트를 진행하면서 변경해가면서 적정수를 찾는다\n",
    "\n",
    "def create_fire_model():\n",
    "    fire_model = Sequential()\n",
    "    fire_model.add(Dense(64, activation='relu', input_shape=(2,)))\n",
    "    fire_model.add(Dense(64, activation='relu'))\n",
    "    fire_model.add(Dense(64, activation='relu'))\n",
    "    fire_model.add(Dense(64, activation='relu'))\n",
    "    fire_model.add(Dense(2, activation=\"softmax\"))\n",
    "\n",
    "    fire_model.compile(\n",
    "        loss=\"categorical_crossentropy\",\n",
    "        optimizer=\"adam\",\n",
    "        metrics=[\"accuracy\"])\n",
    "    return fire_model\n",
    "\n",
    "# 발사 각도(rad)를 계산할 신경망 생성\n",
    "def create_rad_model():\n",
    "    rad_model = Sequential()\n",
    "    rad_model.add(Dense(64, activation='relu', input_shape=(2,)))\n",
    "    rad_model.add(Dense(64, activation='relu'))\n",
    "    rad_model.add(Dense(64, activation='relu'))\n",
    "    rad_model.add(Dense(64, activation='relu'))\n",
    "    rad_model.add(Dense(1, activation=\"linear\"))\n",
    "\n",
    "    rad_model.compile(\n",
    "        loss=\"mse\",\n",
    "        optimizer=\"adam\",\n",
    "        metrics=[\"mae\"])\n",
    "    return rad_model\n",
    "\n",
    "# 파일에 저장된 모델의 가중치를 로드하여 모델에 적용\n",
    "action_model = create_fire_model()  # 모델생성 및 컴파일\n",
    "action_model.load_weights('action_model_weights.h5')\n",
    "\n",
    "rad_model = create_rad_model()\n",
    "rad_model.load_weights('rad_model_weights.h5')\n",
    "\n",
    "class Target:\n",
    "    def __init__(self):\n",
    "        self.x = 0\n",
    "        self.y = 300                                  # Window 좌표에서 보여야 함으로 화면에 가장 아래쪽(300) 값을 대입 \n",
    "    def move(self):\n",
    "        self.x += 1\n",
    "        self.y = int((1/132) * (self.x-200)**2 + 0)  # 좌표를 이동해야 하는 Target이기 때문에 int로 형변환\n",
    "    def get_state(self):\n",
    "        return self.x, self.y\n",
    "    def reset(self):\n",
    "        self.x = 0\n",
    "        self.y = 300\n",
    "    \n",
    "class Bullet:\n",
    "    def __init__(self, rad):\n",
    "        self.rad = rad\n",
    "        self.x = 195\n",
    "        self.y = 290\n",
    "        self.vx = math.cos(rad)*3\n",
    "        self.vy = -math.sin(rad)*3    # 마찬가지로 Window 좌표로 y가 -로 향해야 총알이 아래에서 위로 발사\n",
    "        self.target_state = (0,0)\n",
    "    def move(self):                   # Boolet의 프레임당 발사속도\n",
    "        self.x += self.vx\n",
    "        self.y += self.vy\n",
    "\n",
    "class MainWindow(QMainWindow):\n",
    "    def __init__(self):\n",
    "        super().__init__()    \n",
    "        self.target = Target() \n",
    "        self.bullets = []\n",
    "        self.label = QLabel()\n",
    "        self.label.setAlignment(Qt.AlignCenter)        # Widow 정중앙에 setting\n",
    "        self.label.setPixmap(QPixmap(400, 300))        # x(400),y(400) 의 pixmap\n",
    "        self.ishit = False            # 표적을 명중시 PainterEvent에서 색을 변하게 하기위한 함수\n",
    "        # Target이 0에서 오른쪽으로 400이동해야 하기때문에 에피소드 횟수를 400으로 함\n",
    "        self.episodes = 400                            # Target이 0부터 400까지(window x) 이동해야 함으로 ep 수를 400으로 줌\n",
    "        self.fireCnt = 0                               # 총알 발사 횟수\n",
    "        self.hits = 0                                  # 발사한 총알이 표적에 명중한 횟수\n",
    "        self.hit_state = []                            # 명중한 총알의 발사당시 표적의 (x,y) 값을 담기위한 list\n",
    "        self.hit_rad = []                              # 명중한 총알의 발사당시 총알 각도\n",
    "        self.timer = QTimer()\n",
    "        self.start = 0                                 # Mode를 변경하기 위한 변수\n",
    "        self.rudder = 90                               # 방향키를 움직였을때 각도를 변하게 하기위한 변수\n",
    "        self.skip = 10                                 # 강화학습 모드일때 너무많은 총알이 발사되는데 시각적으로 보일수 있게 만든 변수\n",
    "        self.rudder_x = 0                              # rudder_x ,rudder_y 수동발사 모드에 각도표시 선을 만들기 위한 변수\n",
    "        self.rudder_y = -280\n",
    "        \n",
    "        move_action = QAction('&Start', self)                # Mode 1   발사각,발사여부 사용자 지정 (수동)\n",
    "        #move_action.setStatusTip(\"Click to start\")\n",
    "        move_action.triggered.connect(self.action_start)\n",
    "        \n",
    "        stop_action = QAction('Stop', self)\n",
    "        stop_action.triggered.connect(self.action_stop)\n",
    "        \n",
    "        autosemi_action = QAction('Semi-auto',self)          # Mode 2 발사각은 강화학습 모델이 계산하고 발사여부만 사용자가 입력(반자동)\n",
    "        autosemi_action.triggered.connect(self.semiauto)\n",
    "        \n",
    "        auto_action = QAction('&Auto',self)                  # Mode 3 강화학습 모델이 발사각,발사여부 판단 (자동)\n",
    "        auto_action.triggered.connect(self.action_auto)    \n",
    "        \n",
    "        toolbar = QToolBar()\n",
    "        self.addToolBar(toolbar)\n",
    "        \n",
    "        toolbar.addAction(move_action)\n",
    "        toolbar.addAction(autosemi_action)\n",
    "        toolbar.addAction(auto_action)\n",
    "        toolbar.addAction(stop_action)\n",
    "\n",
    "        self.setCentralWidget(self.label)\n",
    "    \n",
    "    def paintEvent(self, event):                           #repaint() 호출시 돌아가는 함수\n",
    "        painter = QPainter(self.label.pixmap())\n",
    "        painter.fillRect(QRect(0,0,400,300), Qt.black)     # 화면 지우기\n",
    "        \n",
    "        if self.start==1 :                                # Mode가 1일때 발사각도 선을 그리기 위함\n",
    "            pen = QPen(Qt.white, 3, Qt.CustomDashLine)\n",
    "            pen.setDashPattern([4, 3, 2, 5])\n",
    "            painter.setPen(pen)\n",
    "            painter.drawLine(200, 295, (200 + int(self.rudder_x)), (280 + int(self.rudder_y)) ) \n",
    "        \n",
    "        painter.setPen(QPen(Qt.white,  2, Qt.SolidLine))   # Target의 테두리 선\n",
    "        brush = None\n",
    "        if self.ishit:\n",
    "            brush = QBrush(Qt.white, Qt.SolidPattern)      # 폭발시 흰색으로 타겟을 그림\n",
    "            self.ishit = False\n",
    "        else: brush = QBrush(Qt.red, Qt.SolidPattern)\n",
    "        painter.setBrush(brush)         # 채울 색상, 패턴\n",
    "        # drawEllipse(QRect), QRect(x, y, w, h)\n",
    "        painter.drawEllipse(self.target.x, self.target.y, 20, 20)\n",
    "        #Target의 x,y좌표에 원 그리기\n",
    "        \n",
    "        for b in self.bullets:  #총알을 하나하나 꺼낸다\n",
    "            painter.setPen(Qt.white)\n",
    "            painter.setBrush(QBrush(Qt.white, Qt.SolidPattern))\n",
    "            painter.drawEllipse(int(b.x), int(b.y), 10, 10)\n",
    "        painter.end()\n",
    "        \n",
    "    def set_models(self,actionM,radM):                  # 외부에서 적용한 모델을 넣어주기 위한 함수\n",
    "        self.action_model = actionM\n",
    "        self.rad_model = radM\n",
    "        \n",
    "    def action_move(self):                              \n",
    "        self.timer = QTimer()\n",
    "        self.timer.setInterval(30)\n",
    "        self.timer.timeout.connect(self.move)\n",
    "        self.timer.start()\n",
    "        \n",
    "    def action_start(self):                           # Mode 1일 경우(수동)\n",
    "        self.start = 1\n",
    "        \n",
    "    def semiauto(self):                               # Mode 2일 경우 (반자동)\n",
    "        self.start = 2 \n",
    "        \n",
    "    def action_auto(self):                            #Mode 3일경우 (자동)\n",
    "        self.start= 3\n",
    "        state = self.target.get_state()               #현재의 Target 정보를 step 함수와 연결해 step이 돌아가는동안 계속 상태정보를 가져옴\n",
    "        prob = action_model.predict(np.array(state).reshape(-1,2))  # 발사여부를 결정하는 Model\n",
    "        action = np.argmax(prob[0])\n",
    "        self.skip -= 1\n",
    "        if self.skip!=0 :\n",
    "            action = 0\n",
    "        else :\n",
    "            self.skip=10\n",
    "        rad = rad_model.predict(np.array(state).reshape(-1,2))       # 발사각도를 결정하는 Model\n",
    "        return action,rad\n",
    "    \n",
    "\n",
    "\n",
    "    def action_stop(self):\n",
    "        self.timer.stop()\n",
    "        \n",
    "    def move(self):\n",
    "        self.target.move()\n",
    "        for b in self.bullets:\n",
    "            b.move()\n",
    "            #포탄의 y좌표가 천장에 닿았을때 or x좌표가 왼쪽,오른쪽에 닿앗을때\n",
    "            if b.y<=-10 or b.x<=0 or b.x>=400:\n",
    "                self.bullets.remove(b)\n",
    "            # 타겟과 발사체의 충돌(명중) 검사\n",
    "            # 피타고라스 정의를 사용\n",
    "            if ((self.target.x-b.x)**2 + (self.target.y-b.y)**2) < (20**2) :\n",
    "                #명중 했을때의 타겟위치의 상태\n",
    "                self.hit_state.append(b.target_state)\n",
    "                #명중 했을때의 타겟위치의 총알의 시작각도\n",
    "                self.hit_rad.append(b.rad)\n",
    "                try:\n",
    "                    #명중시 그 탄환 삭제 위에서 remove된 총알을 또 삭제할려고 할\n",
    "                    #때 오류가 발생함으로\n",
    "                    # 그 오류를 그냥 pass하기 위해 try except를 사용함\n",
    "                    # 또는 elif를 사용하면 문제가 사라짐\n",
    "                    self.bullets.remove(b)\n",
    "                except:\n",
    "                    pass\n",
    "                # ishit 맞췄을시에 Target을 흰색으로 표시하기 위한 변수\n",
    "                self.ishit = True \n",
    "                self.hits += 1\n",
    "        #좌표가 바뀔때 마다 화면을 다시그리기 위한 함수 repaint()\n",
    "        self.repaint()\n",
    "\n",
    "    def keyPressEvent(self, evt):               #사용자가 키보드를 입력할시 발생하는 Event 함수\n",
    "        if evt.key()==Qt.Key_Space:\n",
    "            if self.start==1 :\n",
    "                rad = math.radians(self.rudder)\n",
    "                self.step(1,rad)\n",
    "                \n",
    "            elif self.start==2:\n",
    "                while True:\n",
    "                    state = self.target.get_state()\n",
    "                    prob = action_model.predict(np.array(state).reshape(-1,2))\n",
    "                    if np.argmax(prob[0])==1: #쏠때가 아니라면 쏘지 않는다\n",
    "                        rad = rad_model.predict(np.array(state).reshape(-1,2))\n",
    "                        self.step(1,rad)\n",
    "                        break\n",
    "        if evt.key() ==Qt.Key_Right: \n",
    "            self.rudder -= 5                              # 탄환이 움직이는 각도\n",
    "            self.rudder_x = math.cos(math.radians(self.rudder))*200   #현재 각도로 x 와 y의 삼각비를 구해 painter 함수에 적용\n",
    "            self.rudder_y = -math.sin(math.radians(self.rudder))*200\n",
    "        if evt.key()==Qt.Key_Left:\n",
    "            self.rudder += 5\n",
    "            self.rudder_x = math.cos(math.radians(self.rudder))*200\n",
    "            self.rudder_y = -math.sin(math.radians(self.rudder))*200\n",
    "                \n",
    "    def fire(self, rad):\n",
    "        b = Bullet(rad)\n",
    "        #총알이 만들어 졌을 당시에 target의 현재위치를 총알에 저장함\n",
    "        b.target_state = self.target.get_state()\n",
    "        #그 총알을 총알리스트에 담아준다\n",
    "        self.bullets.append(b)\n",
    "        #총알을 몇번 발사했는지 확인하는 변수 fireCnt\n",
    "        self.fireCnt += 1\n",
    "        \n",
    "    def reset(self): # 에피소드가 끝나고 새로 에피소드를 시작할때\n",
    "        self.target.reset()\n",
    "        self.fireCnt = 0\n",
    "        self.hits = 0\n",
    "        self.bullets.clear() # bullets안에 있는 총알들을 전부 없앰\n",
    "        self.episodes = 400  # \n",
    "        return self.target.get_state() # Target의 현재위치를 return 해준다\n",
    "        \n",
    "    def step(self, action, rad):\n",
    "        self.episodes -= 1\n",
    "        done = False\n",
    "        if self.episodes == 0:\n",
    "            done = True\n",
    "        self.rad = rad\n",
    "        \n",
    "        if self.start==3:\n",
    "            action,rad = self.action_auto()\n",
    "        \n",
    "        if action==1 : #action 1일경우(발사)에만 fire함수를 돌려줌\n",
    "            self.fire(rad)\n",
    "        self.move()\n",
    "        #현재상태, 보상, 끝났는지 여부, 딕셔너리\n",
    "        return self.target.get_state(),0,done,{}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Thread를 이용한 Window 실행\n",
    "# QMainWindow를 실행할 때는 QApplication 인스턴스의 exec_()함수를 실행해야 한다\n",
    "# exec_()함수는 이벤트 루프(무한루프)를 실행하므로 exec_() 아래에 있는 코드는 실행되지 않는다\n",
    "# 그러므로 QMainWindow 와 함께 다른 코드를 실행하려면 아래와 같이 한개의 Thread로 실행하면 된다\n",
    "\n",
    "import threading\n",
    "\n",
    "#나중에 아래 코드에서 window를 또 사용할 일이 생기기 때문에 전역변수로 선언해줌.\n",
    "window = None\n",
    "\n",
    "def start_window():\n",
    "    app = QApplication(sys.argv)\n",
    "    global window\n",
    "    window = MainWindow()\n",
    "    window.show()\n",
    "    app.exec_()\n",
    "\n",
    "win_thread = threading.Thread(target=start_window)\n",
    "win_thread.start()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test\n",
    "import time\n",
    "\n",
    "window.set_models(action_model, rad_model)\n",
    "\n",
    "for e in range(10):\n",
    "    state = window.reset()\n",
    "    done = False\n",
    "    while not done:\n",
    "        _,_,done,_ = window.step(0,0)\n",
    "        time.sleep(0.02)\n",
    "    print('Episode %s fires %s hits %s' % (e+1, window.fireCnt, window.hits) )\n",
    "print('테스트 종료')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
